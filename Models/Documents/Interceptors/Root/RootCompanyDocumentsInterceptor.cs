using NHibernate;
using NHibernate.Criterion;
using RadialReview.Accessors;
using RadialReview.Models.Application;
using RadialReview.Models.Documents.Interceptors.Data;
using RadialReview.Models.L10;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace RadialReview.Models.Documents.Interceptors {
  public class RootCompanyDocumentsInterceptor : IDocumentFolderInterceptor_Unsafe {

    public bool ShouldExecute(ISession s, DocumentsFolder folder) {
      return FolderConsts.RootCompanyDocumentsFolder.InterceptorMatches(folder);
    }

    public async Task<List<DocumentItemVM>> GeneratedDocumentItems(ISession s, UserOrganizationModel caller, DocumentsFolder folder) {
      return new List<DocumentItemVM>();
    }

    public async Task OnBeforeLoad(ISession s, UserOrganizationModel caller, DocumentsFolder folder) {
      var applyFilter = folder.GetInterceptorProperty("ApplyFilter", true);
      var applyRename = folder.GetInterceptorProperty("ApplyRename", true);

      var subfoldersQ = s.QueryOver<DocumentsFolder>()
                .WithSubquery.WhereProperty(x => x.Id)
                .In(DocumentsAccessor.Criterions.GetItemIdsInFolder_IncludingDeletedItems(folder.Id, DocumentItemType.DocumentFolder))
                .Future();
      var meetingCriteria = QueryOver.Of<L10Recurrence>()
                    .Where(x => x.DeleteTime == null && x.OrganizationId == folder.OrgId)
                    .Select(Projections.Distinct(Projections.Property<L10Recurrence>(x => x.Id)));
      var meetingsQ = s.QueryOver<L10Recurrence>()
                  .WithSubquery.WhereProperty(x => x.Id)
                  .In(meetingCriteria)
                  .Select(x => x.Id, x => x.Name)
                  .Future<object[]>()
                  .Select(x => new NameId((string)x[1], (long)x[0]));
      List<NameId> meetings;
      if (applyFilter) {
        var memberCountQ = s.QueryOver<L10Recurrence.L10Recurrence_Attendee>()
                    .WithSubquery.WhereProperty(x => x.L10Recurrence.Id)
                    .In(meetingCriteria)
                    .SelectList(list => list.SelectCount(p => p.Id).SelectGroup(p => p.L10Recurrence.Id))
                    .Future<object[]>()
                    .Select(x => Tuple.Create((long)x[1], (int)x[0]));
        meetings = meetingsQ.ToList();
        var memberCountLookup = memberCountQ.ToList().ToDefaultDictionary(x => x.Item1, x => x.Item2, x => 0);
        meetings = meetings.Where(x => ShouldIncludeMeetings(x.Name, memberCountLookup[x.Id])).ToList();
      } else {
        meetings = meetingsQ.ToList();
      }

      var subfolders = subfoldersQ.ToList();
      var addRemove = SetUtility.AddRemove(
        subfolders.SelectNotNull(x => x.GetInterceptorData<MeetingFolderData>()), x => x.RecurrenceId,
        meetings, x => x.Id
      );

      var companyName = s.Get<OrganizationModel>(folder.OrgId).GetName();

      var now = DateTime.UtcNow;
      foreach (var addedMeeting in addRemove.AddedValues) {
        var name = addedMeeting.Name;
        var recurId = addedMeeting.Id;
        if (applyRename) {
          name = FormatName(name);
        }
        var data = new MeetingFolderData() { OrgId = folder.OrgId, RecurrenceId = recurId };
        var f = DocumentsFolder.CreateFrom(name, "Team", folder.OrgId, null, true, FolderConsts.RootCompanyTeamDocumentsFolder, data);
        s.Save(f);

        await DocumentsAccessor._SaveLink_Unsafe(s, caller, folder, f, folder.OrgId, false);
        //var link = DocumentItemLocation.CreateFrom(folder, f);
        //s.Save(link);
        PermissionsAccessor.InitializePermItemsAutoGenerated_Unsafe(s, folder.OrgId, PermItem.ResourceType.DocumentsFolder, f.Id, PermTiny.InheritedFromL10Recurrence(recurId));
      }
    }
    public async Task OnAfterLoad(DocumentsFolderVM folderVM) {
      //noop
    }


    public async Task OnAfterLink(ISession s, UserOrganizationModel caller, DocumentsFolder folder, DocumentItemLocation location) {
      //noop
    }
    public async Task OnAfterUnlink(ISession s, UserOrganizationModel caller, DocumentsFolder fromFolder, DocumentItemLocation location) {
      //noop
    }


    private static Regex DuplicateSpaces = new Regex(@"\s+");

    private bool ShouldIncludeMeetings(string name, int count) {
      //excludes same page meetings, quarterlies, and test meetings
      if (count <= 2)
        return false;
      if (string.IsNullOrWhiteSpace(name))
        return false;

      //standardize name
      name = name.ToLower();
      name = " " + DuplicateSpaces.Replace(name, " ").Trim() + " ";

      var blacklist = new string[]{
        " spm ", "same page", "samepage","quarterly", "test"
				//"checkin", "check in",
			};

      if (blacklist.Any(x => name.Contains(x)))
        return false;

      return true;
    }
    private static string ReplaceCaseInsensitive(string input, string search, string replacement) {
      string result = Regex.Replace(
        input,
        Regex.Escape(search),
        replacement.Replace("$", "$$"),
        RegexOptions.IgnoreCase
      );
      return result;
    }

    private string FormatName(string name) {
      var origName = name;
      name = name ?? "";
      name = name.Trim();

      var removeEnd = new string[] { "weekly meeting", "l-10 meeting", "team", "l10", "l-10", "meeting" };
      foreach (var r in removeEnd) {
        if (name.ToLower().EndsWith(r)) {
          name = name.Substring(0, name.Length - r.Length);
          break;
        }
      }
      name = name.Trim();
      var skipAppend = new string[] { "dept", "department", "team" };

      if (!skipAppend.Any(x => name.ToLower().EndsWith(x))) {
        name = name + " Team";
      }

      name = name.Trim();
      if (name.Length == 0) {
        if (!skipAppend.Any(x => name.ToLower().EndsWith(x))) {
          return origName + " Team";
        } else {
          return origName;
        }
      }
      return name;
    }
  }
}